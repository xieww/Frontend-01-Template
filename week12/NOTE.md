# 每周总结可以写在这里

## 字符串分析与模式匹配

- 字典树(Hash 树的一种)
  - 大量字符串的完整模式匹配
- [KMP(Knuth-Morris-Pratt)](https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95)
  - 长字符串中找子串 O(m+n)
- WildCard 通配符算法
  - 长字符串中找子串升级版
- 正则
  - 字符串通用模式匹配
- 状态机
  - 通用的字符串分析
- LL LR
  - 字符串多层级结构分析

> KMP 算法

    Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这三人的姓氏命名此算法。

    算法流程：

    假设现在文本串S匹配到i位置，模式串P匹配到j位置
    如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令i++，j++，继续匹配下一个字符；
    如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令i不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next[j]位。
    换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next值，即移动的实际位数为：j - next[j]，且此值大于等于1。
    很快，你也会意识到next数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如，如果 next[j] = k，代表j之前的字符串中有最大长度为k的相同前缀后缀。

    此也意味着在某个字符失配时，该字符对应的 next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next[j]的位置）。如果next[j]等于0或 -1，则跳到模式串的开头字符，若 next[j] = k 且 k > 0，代表下次匹配跳到j之前的某个字符，而不是跳到开头，且具体跳过了 k 个字符。
